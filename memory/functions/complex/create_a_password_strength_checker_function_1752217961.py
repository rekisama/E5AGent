"""
Function: create_a_password_strength_checker_function_1752217961
Generated by E5Agent Function Registry
Storage Type: complex
Created: 2025-07-15T13:57:07.521157
"""

import re
import math
from typing import Dict, List, Any

def create_a_password_strength_checker_function_1752217961(password: str) -> Dict[str, Any]:
    """
    Evaluates password strength based on multiple criteria and provides improvement suggestions.

    The function checks:
    - Length (minimum 12 characters recommended)
    - Presence of uppercase, lowercase, numbers, and special characters
    - Character diversity and entropy
    - Common patterns and dictionary words
    - Sequential or repeated characters

    Parameters:
        password (str): The password string to evaluate

    Returns:
        Dict[str, Any]: A dictionary containing:
            - 'score' (int): Strength score from 1 (weak) to 5 (strong)
            - 'feedback' (List[str]): List of improvement suggestions
            - 'entropy' (float): Calculated entropy bits
            - 'length' (int): Password length

    Examples:
        >>> create_a_password_strength_checker_function_1752217961('weakpass')
        {'score': 1, 'feedback': ['Too short (minimum 12 characters recommended)', ...], ...}

        >>> create_a_password_strength_checker_function_1752217961('S7r0ngP@$$w0rd!')
        {'score': 4, 'feedback': ['Good length', ...], ...}
    """
    if not isinstance(password, str):
        return {
            'score': 0,
            'feedback': ['Invalid input: password must be a string'],
            'entropy': 0.0,
            'length': 0
        }

    feedback = []
    score = 0
    length = len(password)

    # Common weak passwords and patterns to check against
    common_passwords = {
        'password', '123456', 'qwerty', 'letmein', 'welcome',
        'admin', 'password1', '12345678', '123456789', '123123'
    }
    common_patterns = [
        r'(\w)\1{2,}',  # Repeated characters
        r'123\d*',      # Sequential numbers
        r'qwerty\d*',   # Keyboard patterns
        r'abc\d*',      # Alphabet sequences
    ]

    # Character type checks
    has_lower = any(c.islower() for c in password)
    has_upper = any(c.isupper() for c in password)
    has_digit = any(c.isdigit() for c in password)
    has_special = any(not c.isalnum() for c in password)

    # Calculate character diversity
    unique_chars = len(set(password))
    diversity = unique_chars / length if length > 0 else 0

    # Calculate entropy
    char_pool = 0
    if has_lower:
        char_pool += 26
    if has_upper:
        char_pool += 26
    if has_digit:
        char_pool += 10
    if has_special:
        char_pool += 32  # Approximate common special chars

    entropy = length * math.log2(char_pool) if char_pool > 0 else 0

    # Length check
    if length < 8:
        feedback.append("Very short (minimum 12 characters recommended)")
    elif length < 12:
        feedback.append("Too short (minimum 12 characters recommended)")
    else:
        feedback.append("Good length")
        score += 1

    # Character diversity checks
    if not has_lower:
        feedback.append("Missing lowercase letters")
    else:
        score += 0.5

    if not has_upper:
        feedback.append("Missing uppercase letters")
    else:
        score += 0.5

    if not has_digit:
        feedback.append("Missing numbers")
    else:
        score += 0.5

    if not has_special:
        feedback.append("Missing special characters")
    else:
        score += 0.5

    # Diversity check
    if diversity < 0.5:
        feedback.append(f"Low character diversity ({diversity:.1%} unique characters)")
    else:
        score += 0.5

    # Entropy check
    if entropy < 40:
        feedback.append(f"Low entropy ({entropy:.1f} bits)")
    elif entropy < 60:
        feedback.append(f"Moderate entropy ({entropy:.1f} bits)")
        score += 1
    else:
        feedback.append(f"High entropy ({entropy:.1f} bits)")
        score += 1.5

    # Common password checks
    if password.lower() in common_passwords:
        feedback.append("Common dictionary password")
        score = max(1, score - 1)

    for pattern in common_patterns:
        if re.search(pattern, password, re.IGNORECASE):
            feedback.append("Contains common pattern")
            score = max(1, score - 0.5)
            break

    # Final score adjustment (1-5 scale)
    score = min(5, max(1, round(score)))

    return {
        'score': score,
        'feedback': feedback,
        'entropy': round(entropy, 2),
        'length': length
    }